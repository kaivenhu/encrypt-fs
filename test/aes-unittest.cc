#include <gtest/gtest.h>

#include "../src/aes.h"
#include "utils.h"

using encfs::aes::AES;
using encfs::test_utils::IsVectorEqual;
using std::vector;

TEST(aes_128, key_expansion)
{
    AES aes_test({0x24, 0x75, 0xA2, 0xB3, 0x34, 0x75, 0x56, 0x88, 0x31, 0xE2,
                  0x12, 0x00, 0x13, 0xAA, 0x54, 0x87});
    vector<uint32_t> ans_test = {
        0x2475A2B3, 0x34755688, 0x31E21200, 0x13AA5487, 0x8955B5CE, 0xBD20E346,
        0x8CC2F146, 0x9F68A5C1, 0xCE53CD15, 0x73732E53, 0xFFB1DF15, 0x60D97AD4,
        0xFF8985C5, 0x8CFAAB96, 0x734B7483, 0x13920E57, 0xB822DEB8, 0x34D8752E,
        0x479301AD, 0x54010FFA, 0xD454F398, 0xE08C86B6, 0xA71F871B, 0xF31E88E1,
        0x86900B95, 0x661C8D23, 0xC1030A38, 0x321D82D9, 0x62833EB6, 0x049FB395,
        0xC59CB9AD, 0xF7813B74, 0xEE61ACDE, 0xEAFE1F4B, 0x2F62A6E6, 0xD8E39D92,
        0xE43FE3BF, 0x0EC1FCF4, 0x21A35A12, 0xF940C780, 0xDBF92E26, 0xD538D2D2,
        0xF49B88C0, 0x0DDB4F40,
    };
    EXPECT_TRUE(IsVectorEqual(ans_test, aes_test.round_key()));

    AES aes_seq({0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
                 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10});
    vector<uint32_t> ans_seq = {
        0x01020304, 0x05060708, 0x090A0B0C, 0x0D0E0F10, 0xAB74C9D3, 0xAE72CEDB,
        0xA778C5D7, 0xAA76CAC7, 0x91000F7F, 0x3F72C1A4, 0x980A0473, 0x327CCEB4,
        0x858B825C, 0xBAF943F8, 0x22F3478B, 0x108F893F, 0xFE2CF796, 0x44D5B46E,
        0x6626F3E5, 0x76A97ADA, 0x3DF6A0AE, 0x792314C0, 0x1F05E725, 0x69AC9DFF,
        0x8CA8B657, 0xF58BA297, 0xEA8E45B2, 0x8322D84D, 0x5FC955BB, 0xAA42F72C,
        0x40CCB29E, 0xC3EE6AD3, 0xF7CB3395, 0x5D89C4B9, 0x1D457627, 0xDEAB1CF4,
        0x8E578C88, 0xD3DE4831, 0xCE9B3E16, 0x103022E2, 0xBCC41442, 0x6F1A5C73,
        0xA1816265, 0xB1B14087,
    };
    EXPECT_TRUE(IsVectorEqual(ans_seq, aes_seq.round_key()));

    AES aes_zero({0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00});
    vector<uint32_t> ans_zero = {
        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x62636363, 0x62636363,
        0x62636363, 0x62636363, 0x9B9898C9, 0xF9FBFBAA, 0x9B9898C9, 0xF9FBFBAA,
        0x90973450, 0x696CCFFA, 0xF2F45733, 0x0B0FAC99, 0xEE06DA7B, 0x876A1581,
        0x759E42B2, 0x7E91EE2B, 0x7F2E2B88, 0xF8443E09, 0x8DDA7CBB, 0xF34B9290,
        0xEC614B85, 0x1425758C, 0x99FF0937, 0x6AB49BA7, 0x21751787, 0x3550620B,
        0xACAF6B3C, 0xC61BF09B, 0x0EF90333, 0x3BA96138, 0x97060A04, 0x511DFA9F,
        0xB1D4D8E2, 0x8A7DB9DA, 0x1D7BB3DE, 0x4C664941, 0xB4EF5BCB, 0x3E92E211,
        0x23E951CF, 0x6F8F188E,
    };
    EXPECT_TRUE(IsVectorEqual(ans_zero, aes_zero.round_key()));

    AES aes_ff({0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF});
    vector<uint32_t> ans_ff = {
        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xE8E9E9E9, 0x17161616,
        0xE8E9E9E9, 0x17161616, 0xADAEAE19, 0xBAB8B80F, 0x525151E6, 0x454747F0,
        0x090E2277, 0xB3B69A78, 0xE1E7CB9E, 0xA4A08C6E, 0xE16ABD3E, 0x52DC2746,
        0xB33BECD8, 0x179B60B6, 0xE5BAF3CE, 0xB766D488, 0x045D3850, 0x13C658E6,
        0x71D07DB3, 0xC6B6A93B, 0xC2EB916B, 0xD12DC98D, 0xE90D208D, 0x2FBB89B6,
        0xED5018DD, 0x3C7DD150, 0x96337366, 0xB988FAD0, 0x54D8E20D, 0x68A5335D,
        0x8BF03F23, 0x3278C5F3, 0x66A027FE, 0x0E0514A3, 0xD60A3588, 0xE472F07B,
        0x82D2D785, 0x8CD7C326,
    };
    EXPECT_TRUE(IsVectorEqual(ans_ff, aes_ff.round_key()));
}

int main(int argc, char **argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
